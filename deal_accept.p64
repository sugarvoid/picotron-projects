picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM4OjM5Iixtb2RpZmllZD0iMjAyNS0w
My0yOSAxOToyMzozNSIscmV2aXNpb249ODA0XV1sejQAjAAAABoxAADzIXtbMF09e2JtcD1weHUA
QyAQEATwVgcQB8AX0BfABxAH8FYsZmxhZ3M9MCxwYW5feAgAynk9MCx6b29tPTh9LD4AQAAH0AcE
AC-wzjkAHC-w8DEA------------------------------------------------------------
----plBtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM5OjEyIixtb2RpZmllZD0iMjAyNS0w
My0yOSAxOToyMzozNSJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM4OjM5Iixtb2RpZmllZD0iMjAyNS0w
My0yOSAxOToyMzozNSIscmV2aXNpb249NzgxXV1sejQAaAAAAFgQAADwCHt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDMyAwAvIjABAP--------------------vxCCIpLGhpZGRlbj1mYWxzZSxwYW5feD0w
CADSeT0wLHRpbGVfaD0xNgoAEHcKAIB6b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM5OjEyIixtb2RpZmllZD0iMjAyNS0w
My0yOSAxOToyMzozNSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM4OjQwIixtb2RpZmllZD0iMjAyNS0w
My0yOSAxOToyMzozNSIscmV2aXNpb249Nzg0XV1sejQA3QAAALYKAAD-MHB4dQADKAAABAAED0AQ
Ag4AAaABIAKgDgAPEAAN8MoBAgNADw_QBAUGB0AMkAgJCgtADJAPDA8NDw4MQAzw-wEA6-8nqgEQ
Bg8gEAEgASAB8AACEAIOEAEgDyEgATAPQPDDDygP--DGD-gKD-8PgA-3Dw0B8AkBEAYOMAD-----
-70f-wEArPMuyA9AAAoGMA--AA0PKA8zD0n9KwANIP0rDg0u-SrwcA9AAA8QDwMwDzoPJA8fDxwP
Ew8RDw79KWD9KW79KSAAP0D9sAoAcB--AQD-1lD-----3Q==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM5OjEyIixtb2RpZmllZD0iMjAyNS0w
My0yOSAxOToyMzozNSJdXQ==
:: button.lua
--[[pod_format="raw",created="2025-03-27 23:46:57",modified="2025-03-29 17:45:29",revision=606]]

button = {}
button.__index = button

function button.new(str, pos, callback, col)
    local _b = setmetatable({}, button)
    _b.text = str
    _b.x = pos[1]
    _b.y = pos[2]
    _b.w = 50
    _b.h = 50
    _b.callback = callback
    _b.b_color = 1
    _b.col = col
    _b.hovered = false
    _b.txt_col = 7
    _b.index = idx
    return _b
end

function button:update()
	self.is_hovered = is_colliding(mx, my, self)
end

function button:get_value()
    return self.value
end

function button:was_clicked()
    self:callback()
end

function button:draw()
 	rectfill(self.x, self.y, self.x + self.w,self.y + self.h, self.col)
	rect(self.x, self.y, self.x + self.w,self.y + self.h, self.col)
   print(self.text, self.x + 8, self.y + 22, self.txt_col)

   if self.is_hovered then
   	rect(self.x, self.y, self.x + self.w, self.y + self.h, 7)
   end
end

function is_colliding(m_x, m_y, box)
    if m_x < box.x + box.w and
        m_x > box.x and
        m_y < box.y + box.h and
        m_y > box.y then
        return true
    else
        return false
    end
end

:: case.lua
--[[pod_format="raw",created="2025-03-27 23:46:24",modified="2025-03-29 19:23:35",revision=843]]

--function show_case_va4lue(c)
  --  print("Case " .. c.cover_num .. " had", 185, 140, FONT_COLOR, false, 1, true)
   -- print(c.inside_num, 185, 40, 11, FONT_COLOR)
--end

case = {}
case.__index = case

case_col = 6
case_hover_col = 9 

function case.new(num, value, pos)
    local _c = setmetatable({}, case)
    _c.number = num
    _c.value = value
    _c.x = pos.x
    _c.y = pos.y
    --_c.home_x = pos.x
    --_c.home_y = pos.y
    _c.w = 20
    _c.open_t = 500
    _c.h = 15
    _c.hovered = false
    _c.picked = false
   -- _c.spot = spot
    _c.visable = true
    _c.move_t = 0
    _c.move_p = 121
    _c.end_loc = { 200, 60 }
    
  	_c.col = 6
  	_c.hover_col = 9  
  
    if num <= 9 then
        _c.txt_pos = { _c.x + 8, _c.y + 6 }
    else
        _c.txt_pos = { _c.x + 5, _c.y + 6 }
    end
    return _c
end

function case:update()

	self.is_hovered = is_colliding(mx, my, self)

	if self.is_hovered then
		self.col = case_hover_col
	else
		self.col = case_col
	end


		
    --self.is_hovered = self.spot[1] == selector_index[1] and self.spot[2] == selector_index[2]
    --if self.move_p < self.move_t then
    	--is_case_opening = true
      -- 	self.move_p = self.move_p + 1
        --self.x = lerp(self.x, self.end_loc[1], self.move_p / self.move_t)
        --self.y = lerp(self.y, self.end_loc[2], self.move_p / self.move_t)

        --if self.number <= 9 then
          --  self.txt_pos = { self.x + 8, self.y + 6 }
        --else
          --  self.txt_pos = { self.x + 5, self.y + 6 }
        --end

        --if self.x == self.end_loc[1] and self.y == self.end_loc[2] then
            
            --is_case_opening = false
      		--todo: prevent player from clicking a new case before current is ready
           -- can_player_input = true
            --can_player_click = true
        --end
   -- end
end

function case:was_clicked()
    --can_player_input = false
    
    --self.move_t = 120
    --self.open_t = 0
    --self.move_p = 0
    self.picked = true
	if player_case == nil then
		player_case = self
      goto_next_round()
    	self.update=function(self) end -- prevent checkinh for mouse
    	self.col = 12
    	sfx(0)
   	return
   else
		self.visable = false
   end
	--open_case(self)
	cases_to_pick = clamp(0, cases_to_pick - 1, 6)
	case_manager:reset(self)
   update_game_value(self.value, false)

    
end

function case:draw()
    if self.visable then
    	rect(self.x, self.y, self.x + 20, self.y + 15, self.col)
      print(self.number, self.txt_pos[1], self.txt_pos[2], self.col)
    end
        --else
            --rect(self.x, self.y, self.x + 20, self.y + 15, 6)
            --print(self.number, self.txt_pos[1], self.txt_pos[2], 6)
       --end
    ---else
        --if self.is_hovered then
            --rect(self.home_x, self.home_y, self.home_x + 20, self.home_y + 15, 4)
        --else
            --rect(self.home_x, self.home_y, self.home_x + 20, self.home_y + 15, 14)
        --end
    --end
end

--function open_case(c)
  --  can_player_input = false
   -- case_manager:reset(c)
    --update_game_value(c.value, false)
--end

function is_colliding(m_x, m_y, box)
    if m_x < box.x + box.w and
        m_x > box.x and
        m_y < box.y + box.h and
        m_y > box.y then
        return true
    else
        return false
    end
end
:: main.lua
--[[pod_format="raw",created="2025-03-27 22:38:39",modified="2025-03-29 19:23:35",revision=1095]]

include "case.lua"
include "button.lua"
include "topbar.lua"

FONT_COLOR = 9
PLEASE_RENAME = { 6, 5, 4, 3, 2, 1, 1, 1, 0 }
BORDER_COLOR = 12
GAMESTATES = {
    title = 0,
    pick_case = 1,
    display_values = 2,
    offer = 3,
    game_over = 5,
    deal_accepted = 6
}

_start_y = 18

function _init()
	current_offer = 0
player_case = nil
show_values = false
cases_to_pick = 7
	round = 0
	last_case = nil
	can_player_click = true
	mx, my, mb = nil, nil, nil
	game_state = GAMESTATES.title
	is_case_opening = false
	btn_deal = button.new("ACCEPT", { 20, 50 }, accept_deal, 27, 1)
	btn_no_deal = button.new("REJECT", { 95, 50 }, reject_deal, 24, 2)

 offer_btns = {}

add(offer_btns, btn_deal)
add(offer_btns, btn_no_deal)

	vid(3)
	--window{
            --width      = 250,
            --height     = 143,
         --   resizeable = false,
          --  title      = "Accept or Reject"
        --}
end

function _update()
    top_bar:update()
    
  if not is_case_opening then
    	mx,my,mb = mouse()
   end
   if mb == 1 then
		if m_delay == 0 then
			on_mouse_click(mx, my)
			m_delay+=1
			return
		end
	else
		m_delay = 0
  	end
   
  can_player_click = not is_case_opening
	
    if game_state == GAMESTATES.title then

        update_title()
    elseif game_state == GAMESTATES.pick_case then
        update_pick_case()
    elseif game_state == GAMESTATES.offer then
        update_offer()
    elseif game_state == GAMESTATES.deal_accepted then
        update_deal_accepted()
    elseif game_state == GAMESTATES.game_over then
        update_game_over()
    end
end

function _draw()
	cls()
	if game_state == GAMESTATES.title then
        draw_title()
    elseif game_state == GAMESTATES.pick_case then
        draw_pick_case()
        
    elseif game_state == GAMESTATES.offer then
        draw_offer()
        draw_border()
    elseif game_state == GAMESTATES.deal_accepted then
        draw_deal_accepted()
    elseif game_state == GAMESTATES.game_over then
        draw_game_over()
    end
    
   if not is_case_opening then
    spr(1, mx-2, my-2)
    end
    --print(tostr(is_case_opening), 0, 0, 8)
end


function on_mouse_click(x,y)

	if is_case_opening then
		--notify("get out of here")
		return
	end

	--notify("click on " .. x .. "," .. y)
	if game_state == GAMESTATES.title then
		
	elseif game_state == GAMESTATES.pick_case then
	if can_player_click then
		for c in all(cases) do
			--if c.is_hovered then
				if not c.picked and c.is_hovered then
                    --can_player_input = false
                    can_player_click = false
                    c:was_clicked()
                    update_topbar(cases_to_pick)
                    return
            end
            end
            end
			
		--end
	elseif game_state == GAMESTATES.offer then
		
		for b in all(offer_btns) do
			if b.is_hovered then
				b:was_clicked()
				return
			end
		end
	
		--if lbl_play.hovered then
			--lbl_play:do_func()
			--return
		--end
		
	elseif game_state == GAMESTATES.deal_accepted then
		--if lbl_play.hovered then
			--lbl_play:do_func()
			--return
		--end
		
	elseif game_state == GAMESTATES.game_over then
		--if lbl_back_main.hovered then
			--gamestate = GAMESTATES.TITLE
		--end
	end
end


--opening_case_t = 0
row_1_y = 15 + 16
row_2_y = 35 + 16
row_3_y = 55 + 16
row_4_y = 75 + 16

col_1 = 5
col_2 = 30
col_3 = 55
col_4 = 105 - 25
col_5 = 130 - 25
col_6 = 155 - 25



--offer_index = 1


cases = {}

case_manager = {
    t = 90,
    cover_num = 0,
    inside_num = 0,
    update = function(self)
    		is_case_opening = self.t < 90
    		
        if self.t < 90 then
            self.t = self.t + 1
        end
        if self.t >= 90 then
            if cases_to_pick == 0 and round <= 8 then
                game_state = GAMESTATES.offer
                is_case_opening = false
                offer_index = 1
                top_bar:set_text("BANKER'S OFFER")
                current_offer = get_offer()
            else
                if round <= 8 then
                    game_state = GAMESTATES.pick_case
                elseif round == 9 then
                    game_state = GAMESTATES.game_over
                end
            end
        end
    end,
    reset = function(self, case)
        self.t = 0
        self.cover_num = case.number
        self.inside_num = case.value
    end,
}

--case_spots = {
 --   { 0, 0 }, { 0, 1 }, { 0, 2 }, { 0, 3 }, { 0, 4 }, { 0, 5 },
   -- { 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 }, { 1, 4 }, { 1, 5 },
   -- { 2, 0 }, { 2, 1 }, { 2, 2 }, { 2, 3 }, { 2, 4 }, { 2, 5 },
   -- { 3, 0 }, { 3, 1 }, { 3, 2 }, { 3, 3 }, { 3, 4 }, { 3, 5 }
--}

case_pos = {
    { x = col_1, y = row_1_y },
    { x = col_2, y = row_1_y },
    { x = col_3, y = row_1_y },
    { x = col_4, y = row_1_y },
    { x = col_5, y = row_1_y },
    { x = col_6, y = row_1_y },

    { x = col_1, y = row_2_y },
    { x = col_2, y = row_2_y },
    { x = col_3, y = row_2_y },
    { x = col_4, y = row_2_y },
    { x = col_5, y = row_2_y },
    { x = col_6, y = row_2_y },

    { x = col_1, y = row_3_y },
    { x = col_2, y = row_3_y },
    { x = col_3, y = row_3_y },
    { x = col_4, y = row_3_y },
    { x = col_5, y = row_3_y },
    { x = col_6, y = row_3_y },

    { x = col_1, y = row_4_y },
    { x = col_2, y = row_4_y },
    { x = col_3, y = row_4_y },
    { x = col_4, y = row_4_y },
    { x = col_5, y = row_4_y },
    { x = col_6, y = row_4_y },
}


case_values = {
    1,
    3,
    5,
    10,
    25,
    50,
    75,
    100,
    200,
    250,
    500,
    750,
    1000,
    2500,
    5000,
    10000,
    25000,
    50000,
    100000,
    250000,
    500000,
    750000,
    900000,
    1000000
}


game_values = {
    { value = 1,       in_play = true },
    { value = 3,       in_play = true },
    { value = 5,       in_play = true },
    { value = 10,      in_play = true },
    { value = 25,      in_play = true },
    { value = 50,      in_play = true },
    { value = 75,      in_play = true },
    { value = 100,     in_play = true },
    { value = 200,     in_play = true },
    { value = 250,     in_play = true },
    { value = 500,     in_play = true },
    { value = 750,     in_play = true },
    { value = 1000,    in_play = true },
    { value = 2500,    in_play = true },
    { value = 5000,    in_play = true },
    { value = 10000,   in_play = true },
    { value = 25000,   in_play = true },
    { value = 50000,   in_play = true },
    { value = 100000,  in_play = true },
    { value = 250000,  in_play = true },
    { value = 500000,  in_play = true },
    { value = 750000,  in_play = true },
    { value = 900000,  in_play = true },
    { value = 1000000, in_play = true }
}


function reset_game()
    game_state = GAMESTATES.title
    offer_index = 1
    round = 0
    cases_to_pick = 7
    player_case = nil
    for k, v in ipairs(game_values) do
        game_values[k].in_play = true
    end
end

function get_offer()
    local offer
    local values_left = 0
    local sum = 0
    local off_set = 0.50
    for _, v in ipairs(game_values) do
        if v.in_play then
            values_left = values_left + 1
            sum = sum + v.value
        end
    end
    offer = math.floor((sum / values_left) * off_set)
    return offer
end

function update_game_value(value, in_play)
    for _, v in ipairs(game_values) do
        if v.value == value then
            v.in_play = in_play
            break
        end
    end
end

function shuffle(t)
    for i = #t, 1, -1 do
        local j = math.floor(math.random(i)) + 1
        t[i], t[j] = t[j], t[i]
    end
end

function goto_next_round()
    round = round + 1
    cases_to_pick = PLEASE_RENAME[round]
    update_topbar(cases_to_pick)
    if round < 9 then
        game_state = GAMESTATES.pick_case
    end
end

function setup_cases()
    cases = {}
    shuffle(case_values)
    for i = 1, 24 do
        table.insert(cases, case.new(i, case_values[i], case_pos[i]))
    end
end

function start_game()
    setup_cases()
    top_bar:set_text("PICK YOUR CASE")
    game_state = GAMESTATES.pick_case
end

function accept_deal()
    game_state = GAMESTATES.deal_accepted
end

function reject_deal()
    if round < 7 then
        goto_next_round()
    else
        game_state = GAMESTATES.game_over
        round = round + 1
        for _, c in ipairs(cases) do
            if c.picked == false then
                notify("last case #: " .. c.number .. ". This is round: " .. round)
                last_case = c
            end
        end
    end
end




function update_title()
    if key("space") then
        start_game()
    end
end

function update_pick_case()
    case_manager:update()
   -- if can_player_input then
     --   if btnp(2) then
       --     move_selector("up")
      --  elseif btnp(3) then
        --    move_selector("down")
       -- elseif btnp(0) then
         --   move_selector("left")
       -- elseif btnp(1) then
        --    move_selector("right")
       -- end

        --if btnp(4) and not show_values then -- Gamepad (A)
          --  for b in all(cases) do
            --    if not b.picked and b.is_hovered then
              --      can_player_input = false
                --    b:was_clicked()
                  --  update_topbar(cases_to_pick)
              --  end
           -- end
       -- end
 --   end

    for c in all(cases) do
        c:update()
    end
    
  -- for c in all(cases) do
			--c.is_hovered = is_colliding(mx, my, c)
				--l:was_clicked()
			--end
		--end
end

function update_offer()
    btn_deal:update()
    btn_no_deal:update()

   -- if btnp(0) then
     --   offer_index = clamp(1, offer_index - 1, 2)
   -- elseif btnp(1) then
     --   offer_index = clamp(1, offer_index + 1, 2)
   -- end

   -- if btnp(4) then -- Gamepad (A)
     --   for b in all({ btn_deal, btn_no_deal }) do
       --     b:update()
         --   if b.is_hovered then
           --     b:was_clicked()
           -- end
       -- end
   -- end
end

--function is_valid_spot(x, y)
  --  for _, c in ipairs(cases) do
    --    if not c.picked and c.spot[1] == x and c.spot[2] == y then
      --      return true
       -- end
   -- end
    --return false
--end

function update_topbar(n_cases)
    local _txt = ""
    if player_case then
        if round < 1 then
            _txt = "PICK " .. n_cases .. " MORE CASES"
        else
            _txt = "PICK " .. n_cases .. " CASE"
        end
    else
        _txt = "Pick your case"
    end
    top_bar:set_text(_txt)
end

--function move_selector(dir)
  --  if can_player_input then
    --    if dir == "up" then
       --     selector_index[1] = clamp(0, selector_index[1] - 1, 4)
       -- elseif dir == "down" then
          --  selector_index[1] = clamp(0, selector_index[1] + 1, 3)
        --elseif dir == "left" then
          ---  selector_index[2] = clamp(0, selector_index[2] - 1, 5)
        --elseif dir == "right" then
          --  selector_index[2] = clamp(0, selector_index[2] + 1, 5)
        --end
   -- end
--end

function update_deal_accepted()
    if key("space") then
        reset_game()
    end
end

function update_game_over()
    if key("space") then
        reset_game()
    end
end

function draw_border()
    top_bar:draw()
    line(0, 8, 240, 8, BORDER_COLOR)
    line(0, 134, 240, 134, BORDER_COLOR)
    line(0, 0, 240, 0, BORDER_COLOR)
    line(0, 0, 0, 134, BORDER_COLOR)
    line(155, 8, 155, 155, BORDER_COLOR)
    line(239, 0, 239, 134, BORDER_COLOR)
end

function draw_title()
    print("Accept", 50, 42, FONT_COLOR)
    print("or", 80, 56, FONT_COLOR)
    print("Reject", 90, 72, FONT_COLOR)
    print("Press SPACE to play", 70, 110, FONT_COLOR)
end

function draw_pick_case()

	--if case_manager.t < 90 then
	if is_case_opening then
		cls()
		 if case_manager.t < 90 then
        print("Case " .. case_manager.cover_num .. " had", 85, 60, FONT_COLOR)--, false, 1, true)
        print("$" .. comma_value(case_manager.inside_num), 85, 70, FONT_COLOR)--, false, 1, true) --, false, 1, true)
    	end
		return
	end
	

    for _, r in ipairs(cases) do
        if not r.picked or 4 == 4 then
            r:draw()
        end
    end

    draw_display_values()

   

    --print("Click to select", 3, 125, FONT_COLOR, false, 1, true)
    --if player_case then
        --print("Your Case: " .. player_case.number, 3, 125, FONT_COLOR)
    --end
    
   draw_border()

    
end

function draw_display_values()
    
    rectfill(156, 9, 250, 133, 0)
    
    for i = 1, 12 do
        if game_values[i].in_play then
            col = 12
        else
            col = 5
        end
        print("$" .. comma_value(game_values[i].value), 37 + 123, _start_y + (i - 1) * 9, col)
    end

    for i2 = 1, 12 do
        if game_values[i2 + 12].in_play then
            col = 12
        else
            col = 5
        end
        print("$" .. comma_value(game_values[i2 + 12].value), 65 + 123, _start_y + (i2 - 1) * 9, col, false, 1, true)
    end
end

function draw_offer()
    if round == 7 then
        print("LAST OFFER", 56, 20, FONT_COLOR)
    end
    print("Offer: $" .. comma_value(current_offer), 56, 30, FONT_COLOR)
    btn_deal:draw()
    btn_no_deal:draw()
    draw_display_values()
end

function draw_game_over()
    print("You turned down all offers", 60, 30, FONT_COLOR)
    print("Your Case Value", 60, 45, FONT_COLOR)
    print("$" .. comma_value(player_case.value), 60, 58, FONT_COLOR)
    print("SPACE to return to main", 60, 120, FONT_COLOR)
end

function draw_deal_accepted()
    print("You accepted", 60, 30, FONT_COLOR)
    print("$" .. comma_value(current_offer), 60, 38, FONT_COLOR)
    print("Your case had", 60, 50, FONT_COLOR)
    print("$" .. comma_value(player_case.value), 60, 58, FONT_COLOR)

    if current_offer > player_case.value then
        print("Well played", 60, 100, FONT_COLOR)
    else
        print("Better luck next time", 60, 100, FONT_COLOR)
    end

    print("SPACE to return to main", 60, 120, FONT_COLOR)
end


function comma_value(amount)
    local formatted = amount
    local _k = nil
    while true do
        formatted, _k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
        if (_k == 0) then
            break
        end
    end
    return formatted
end

function clamp(low, n, high)
    return math.min(math.max(n, low), high)
end

function lerp(a, b, t)
    return a + (b - a) * t
end



:: topbar.lua
--[[pod_format="raw",created="2025-03-27 22:57:41",modified="2025-03-29 19:23:35",revision=765]]

top_bar = {
    x = 0,
    y = 1,
    str = "test",
    w = 0,
    col = FONT_COLOR,
    set_text = function(self, text)
        self.str = text
        self.w = print(text, 0, -6)
    end,
    draw = function(self)
        print(self.str, self.x, self.y, FONT_COLOR)
    end,
    update = function(self)
        self.x = self.x - 0.5
        if self.x + self.w <= 0 then
            self.x = 241
        end
    end,
}

:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM5OjEyIixpY29uPXVzZXJkYXRhKCJ1
OCIsMTYsMTYsIjAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwNzA3MDcwNzAxMDcw
NzA3MDcwMTA3MDcwNzA3MDEwMTA3MDEwMTA3MDEwNzAxMDEwNzAxMDcwMTAxMDcwMTAxMDcwNzA3
MDcwMTA3MDcwNzA3MDEwNzA3MDcwNzAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDcwNzA3MDcwMTA3MDcwNzA3MDEwNjA2
MDYwNjAxMDEwNzAxMDEwNzAxMDcwMTAxMDcwMTA2MDEwMTA2MDEwMTA3MDcwNzA3MDEwNzA3MDcw
NzAxMDYwNjA2MDYwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMTAxMDEwMTAxMDEwMTA2MDYwNjA2MDEwNzA3MDcwNzAxMDcwNzA3MDcwMTAxMDYw
MTAxMDYwMTA3MDEwMTA3MDEwNzAxMDEwNzAxMDEwNjA2MDYwNjAxMDcwNzA3MDcwMTA3MDcwNzA3
MDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MTAxMDEwMTAxIiksbW9kaWZpZWQ9IjIwMjUtMDMtMjkgMTk6MjM6MzUiLHJ1bnRpbWU9MTYsd29y
a3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMxNjAiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9j
YXRpb249ImNhc2UubHVhIzQzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJ0b3BiYXIu
bHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNl
X2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0
aW9uPSJzZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQ==
:: [eoc]

picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM4OjM5Iixtb2RpZmllZD0iMjAyNS0w
My0yOCAyMToyNDo1OSIscmV2aXNpb249MzgwXV1sejQAjAAAABoxAADzIXtbMF09e2JtcD1weHUA
QyAQEATwVgcQB8AX0BfABxAH8FYsZmxhZ3M9MCxwYW5feAgAynk9MCx6b29tPTh9LD4AQAAH0AcE
AC-wzjkAHC-w8DEA------------------------------------------------------------
----plBtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM5OjEyIixtb2RpZmllZD0iMjAyNS0w
My0yOCAyMToyNDo1OSJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM4OjM5Iixtb2RpZmllZD0iMjAyNS0w
My0yOCAyMToyNDo1OSIscmV2aXNpb249MzU4XV1sejQAaAAAAFgQAADwCHt7Ym1wPXVzZXJkYXRh
KCJpMTYiLDMyAwAvIjABAP--------------------vxCCIpLGhpZGRlbj1mYWxzZSxwYW5feD0w
CADSeT0wLHRpbGVfaD0xNgoAEHcKAIB6b29tPTF9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM5OjEyIixtb2RpZmllZD0iMjAyNS0w
My0yOCAyMToyNDo1OSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM4OjQwIixtb2RpZmllZD0iMjAyNS0w
My0yOCAyMToyNDo1OSIscmV2aXNpb249MzU5XV1sejQAoAAAAAsKAAD-MHB4dQADKAAABAAED0AQ
Ag4AAaABIAKgDgAPEAAN8MoBAgNADw_QBAUGB0AMkAgJCgtADJAPDA8NDw4MQAzw-wEA6-8nqgEQ
Bg8gEAEgASAB8AACEAIOEAEgDyEgATAPQPDDDygP--DGD-gKD-8PgA-3Dw0B8AkBEAYOMAD-----
-70f-wEArM-ID0AADxBA--_w8P8BAP-qUP----8p
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM5OjEyIixtb2RpZmllZD0iMjAyNS0w
My0yOCAyMToyNDo1OSJdXQ==
:: button.lua
--[[pod_format="raw",created="2025-03-27 23:46:57",modified="2025-03-28 21:24:59",revision=325]]

button = {}
button.__index = button

function button.new(str, pos, callback, col, idx)
    local _b = setmetatable({}, button)
    _b.text = str
    _b.x = pos[1]
    _b.y = pos[2]
    _b.w = 50
    _b.h = 50
    _b.callback = callback
    _b.b_color = 1
    _b.col = col
    _b.hovered = false
    _b.index = idx
    return _b
end

function button:update()
    self.is_hovered = self.index == offer_index
end

function button:get_value()
    return self.value
end

function button:was_clicked()
    self:callback()
end

function button:draw()
    rect(self.x, self.y, self.x + self.w,self.y + self.h, self.col)
    if self.callback == accept_deal then
        print(self.text, self.x + 8, self.y + 22, 12)
    else
        print(self.text, self.x + 8, self.y + 22, 12)
    end
    if self.is_hovered then
        rect(self.x, self.y, self.x + self.w, self.y + self.h, 12)
    end
end

function is_colliding(m_x, m_y, box)
    if m_x < box.x + box.w and
        m_x > box.x and
        m_y < box.y + box.h and
        m_y > box.y then
        return true
    else
        return false
    end
end

:: case.lua
--[[pod_format="raw",created="2025-03-27 23:46:24",modified="2025-03-28 21:24:59",revision=362]]

function show_case_value(c)
    print("Case " .. c.cover_num .. " had", 185, 140, FONT_COLOR, false, 1, true)
    print(c.inside_num, 185, 40, 11, FONT_COLOR)
end

case = {}
case.__index = case

case_col = 6
case_hover_col = 9 

function case.new(num, value, pos, spot)
    local _c = setmetatable({}, case)
    _c.number = num
    _c.value = value
    _c.x = pos.x
    _c.y = pos.y
    _c.home_x = pos.x
    _c.home_y = pos.y
    _c.w = 20
    _c.h = 15
    _c.hovered = false
    _c.picked = false
    _c.spot = spot
    _c.visable = true
    _c.move_t = 0
    _c.move_p = 0
    _c.end_loc = { 200, 60 }
    
  	_c.col = 6
  	_c.hover_col = 9  
  
    if num <= 9 then
        _c.txt_pos = { _c.x + 8, _c.y + 6 }
    else
        _c.txt_pos = { _c.x + 5, _c.y + 6 }
    end
    return _c
end

function case:update()
	if self.is_hovered then
		self.col = case_hover_col
	else
		self.col = case_col
	end

	
    --self.is_hovered = self.spot[1] == selector_index[1] and self.spot[2] == selector_index[2]
    if self.move_p < self.move_t then
        self.move_p = self.move_p + 1
        self.x = lerp(self.x, self.end_loc[1], self.move_p / self.move_t)
        self.y = lerp(self.y, self.end_loc[2], self.move_p / self.move_t)

        if self.number <= 9 then
            self.txt_pos = { self.x + 8, self.y + 6 }
        else
            self.txt_pos = { self.x + 5, self.y + 6 }
        end

        if self.x == self.end_loc[1] and self.y == self.end_loc[2] then
            self.visable = false
            can_player_input = true
            can_player_click = true
        end
    end
end

function case:was_clicked()
    can_player_input = false
    self.move_t = 120
    self.picked = true
    if player_case == nil then
        player_case = self
        goto_next_round()
        self.col = 11
        return

     end
	open_case(self)
    cases_to_pick = clamp(0, cases_to_pick - 1, 6)

    
end

function case:draw()
    if self.visable then
        rect(self.x, self.y, self.x + 20, self.y + 15, 14)
        --if self.is_hovered then
            rect(self.x, self.y, self.x + 20, self.y + 15, self.col)
            print(self.number, self.txt_pos[1], self.txt_pos[2], self.col)
        --else
            --rect(self.x, self.y, self.x + 20, self.y + 15, 6)
            --print(self.number, self.txt_pos[1], self.txt_pos[2], 6)
       end
    ---else
        --if self.is_hovered then
            --rect(self.home_x, self.home_y, self.home_x + 20, self.home_y + 15, 4)
        --else
            --rect(self.home_x, self.home_y, self.home_x + 20, self.home_y + 15, 14)
        --end
    --end
end

function open_case(c)
    can_player_input = false
    case_manager:reset(c)
    update_game_value(c.value, false)
end

function is_colliding(m_x, m_y, box)
    if m_x < box.x + box.w and
        m_x > box.x and
        m_y < box.y + box.h and
        m_y > box.y then
        return true
    else
        return false
    end
end
:: main.lua
--[[pod_format="raw",created="2025-03-27 22:38:39",modified="2025-03-28 21:24:59",revision=560]]





include "case.lua"
include "button.lua"

top_bar = include "topbar.lua"


FONT_COLOR = 9
round = 0
please_rename = { 6, 5, 4, 3, 2, 1, 1, 1, 0 }
selector_index = { 0, 0 }
BORDER_COLOR = 12
can_player_input = true
last_case = nil

can_player_click = true

GAMESTATES = {
    title = 0,
    pick_case = 1,
    display_values = 2,
    offer = 3,
    game_over = 5,
    deal_accepted = 6
}

game_state = GAMESTATES.title

mx, my, mb = nil, nil, nil

function _init()
	vid(3)
	--window{
     --       width      = 250,
       --     height     = 143,
         --   resizeable = false,
           -- title      = "Accept or Reject"
        --}
end

function _update()
    top_bar:update()
    mx,my,mb = mouse()
    
   if mb == 1 then
		if m_delay == 0 then
			on_mouse_click(mx, my)
			m_delay+=1
			return
		end
	else
		m_delay = 0
  	end
   
	
    if game_state == GAMESTATES.title then

        update_title()
    elseif game_state == GAMESTATES.pick_case then
        update_pick_case()
    elseif game_state == GAMESTATES.offer then
        update_offer()
    elseif game_state == GAMESTATES.deal_accepted then
        update_deal_accepted()
    elseif game_state == GAMESTATES.game_over then
        update_game_over()
    end
end

function _draw()
	cls()
	if game_state == GAMESTATES.title then
        draw_title()
    elseif game_state == GAMESTATES.pick_case then
        draw_pick_case()
        draw_border()
    elseif game_state == GAMESTATES.offer then
        draw_offer()
        draw_border()
    elseif game_state == GAMESTATES.deal_accepted then
        draw_deal_accepted()
    elseif game_state == GAMESTATES.game_over then
        draw_game_over()
    end
    spr(1, mx-2, my-2)
end


function on_mouse_click(x,y)
	--notify("click on " .. x .. "," .. y)
	if game_state == GAMESTATES.title then
		
	elseif game_state == GAMESTATES.pick_case then
	if can_player_click then
		for c in all(cases) do
			--if c.is_hovered then
				
				if not c.picked and c.is_hovered then
                    can_player_input = false
                    can_player_click = false
                    c:was_clicked()
                    update_topbar(cases_to_pick)
                    return
            end
            end
            end
			
		--end
	elseif game_state == GAMESTATES.offer then
		if lbl_play.hovered then
			lbl_play:do_func()
			return
		end
		
	elseif game_state == GAMESTATES.deal_accepted then
		--if lbl_play.hovered then
			--lbl_play:do_func()
			--return
		--end
		
	elseif game_state == GAMESTATES.game_over then
		--if lbl_back_main.hovered then
			--gamestate = GAMESTATES.TITLE
		--end
	end
end


opening_case_t = 0
row_1_y = 15 + 2
row_2_y = 35 + 2
row_3_y = 55 + 2
row_4_y = 75 + 2

col_1 = 5
col_2 = 30
col_3 = 55
col_4 = 105 - 25
col_5 = 130 - 25
col_6 = 155 - 25

current_offer = 0
player_case = nil
show_values = false
cases_to_pick = 7

offer_index = 1


cases = {}

case_manager = {
    t = 90,
    cover_num = 0,
    inside_num = 0,
    update = function(self)
        if self.t < 90 then
            self.t = self.t + 1
        end
        if self.t >= 90 then
            if cases_to_pick == 0 and round <= 8 then
                game_state = GAMESTATES.offer
                offer_index = 1
                top_bar:set_text("Banker's Offer")
                current_offer = get_offer()
            else
                if round <= 8 then
                    game_state = GAMESTATES.pick_case
                elseif round == 9 then
                    game_state = GAMESTATES.game_over
                end
            end
        end
    end,
    reset = function(self, case)
        self.t = 0
        self.cover_num = case.number
        self.inside_num = case.value
    end,
}

case_spots = {
    { 0, 0 }, { 0, 1 }, { 0, 2 }, { 0, 3 }, { 0, 4 }, { 0, 5 },
    { 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 }, { 1, 4 }, { 1, 5 },
    { 2, 0 }, { 2, 1 }, { 2, 2 }, { 2, 3 }, { 2, 4 }, { 2, 5 },
    { 3, 0 }, { 3, 1 }, { 3, 2 }, { 3, 3 }, { 3, 4 }, { 3, 5 }
}

case_pos = {
    { x = col_1, y = row_1_y },
    { x = col_2, y = row_1_y },
    { x = col_3, y = row_1_y },
    { x = col_4, y = row_1_y },
    { x = col_5, y = row_1_y },
    { x = col_6, y = row_1_y },

    { x = col_1, y = row_2_y },
    { x = col_2, y = row_2_y },
    { x = col_3, y = row_2_y },
    { x = col_4, y = row_2_y },
    { x = col_5, y = row_2_y },
    { x = col_6, y = row_2_y },

    { x = col_1, y = row_3_y },
    { x = col_2, y = row_3_y },
    { x = col_3, y = row_3_y },
    { x = col_4, y = row_3_y },
    { x = col_5, y = row_3_y },
    { x = col_6, y = row_3_y },

    { x = col_1, y = row_4_y },
    { x = col_2, y = row_4_y },
    { x = col_3, y = row_4_y },
    { x = col_4, y = row_4_y },
    { x = col_5, y = row_4_y },
    { x = col_6, y = row_4_y },
}


case_values = {
    1,
    3,
    5,
    10,
    25,
    50,
    75,
    100,
    200,
    250,
    500,
    750,
    1000,
    2500,
    5000,
    10000,
    25000,
    50000,
    100000,
    250000,
    500000,
    750000,
    900000,
    1000000
}


game_values = {
    { value = 1,       in_play = true },
    { value = 3,       in_play = true },
    { value = 5,       in_play = true },
    { value = 10,      in_play = true },
    { value = 25,      in_play = true },
    { value = 50,      in_play = true },
    { value = 75,      in_play = true },
    { value = 100,     in_play = true },
    { value = 200,     in_play = true },
    { value = 250,     in_play = true },
    { value = 500,     in_play = true },
    { value = 750,     in_play = true },
    { value = 1000,    in_play = true },
    { value = 2500,    in_play = true },
    { value = 5000,    in_play = true },
    { value = 10000,   in_play = true },
    { value = 25000,   in_play = true },
    { value = 50000,   in_play = true },
    { value = 100000,  in_play = true },
    { value = 250000,  in_play = true },
    { value = 500000,  in_play = true },
    { value = 750000,  in_play = true },
    { value = 900000,  in_play = true },
    { value = 1000000, in_play = true }
}


function reset_game()
    game_state = GAMESTATES.title
    offer_index = 1
    round = 0
    cases_to_pick = 7
    player_case = nil
    for k, v in ipairs(game_values) do
        game_values[k].in_play = true
    end
end

function get_offer()
    local offer
    local values_left = 0
    local sum = 0
    local off_set = 0.50
    for _, v in ipairs(game_values) do
        if v.in_play then
            values_left = values_left + 1
            sum = sum + v.value
        end
    end
    offer = math.floor((sum / values_left) * off_set)
    return offer
end

function update_game_value(value, in_play)
    for _, v in ipairs(game_values) do
        if v.value == value then
            v.in_play = in_play
            break
        end
    end
end

function shuffle(t)
    for i = #t, 1, -1 do
        local j = math.floor(math.random(i)) + 1
        t[i], t[j] = t[j], t[i]
    end
end

function goto_next_round()
    round = round + 1
    cases_to_pick = please_rename[round]
    update_topbar(cases_to_pick)
    if round < 9 then
        game_state = GAMESTATES.pick_case
    end
end

function setup_cases()
    cases = {}
    shuffle(case_values)
    for i = 1, 24 do
        table.insert(cases, case.new(i, case_values[i], case_pos[i], case_spots[i]))
    end
end

function start_game()
    setup_cases()
    top_bar:set_text("Pick your case")
    game_state = GAMESTATES.pick_case
end

function accept_deal()
    game_state = GAMESTATES.deal_accepted
end

function reject_deal()
    if round < 7 then
        goto_next_round()
    else
        game_state = GAMESTATES.game_over
        round = round + 1
        for _, c in ipairs(cases) do
            if c.picked == false then
                trace("last case #: " .. c.number .. ". This is round: " .. round)
                last_case = c
            end
        end
    end
end

local btn_deal = button.new("ACCEPT", { 20, 50 }, accept_deal, 6, 1)
local btn_no_deal = button.new("REJECT", { 95, 50 }, reject_deal, 2, 2)



function update_title()
	
    if btnp(4) then -- Gamepad (B)
        start_game()
    end
end

function update_pick_case()
    case_manager:update()
    if can_player_input then
        if btnp(2) then
            move_selector("up")
        elseif btnp(3) then
            move_selector("down")
        elseif btnp(0) then
            move_selector("left")
        elseif btnp(1) then
            move_selector("right")
        end

        if btnp(4) and not show_values then -- Gamepad (A)
            for b in all(cases) do
                if not b.picked and b.is_hovered then
                    can_player_input = false
                    b:was_clicked()
                    update_topbar(cases_to_pick)
                end
            end
        end
    end

    for b in all(cases) do
        b:update()
    end
    
   for c in all(cases) do
			c.is_hovered = is_colliding(mx, my, c)
				--l:was_clicked()
			--end
		end
end

function update_offer()
    btn_deal:update()
    btn_no_deal:update()

    if btnp(0) then
        offer_index = clamp(1, offer_index - 1, 2)
    elseif btnp(1) then
        offer_index = clamp(1, offer_index + 1, 2)
    end

    if btnp(4) then -- Gamepad (A)
        for b in all({ btn_deal, btn_no_deal }) do
            b:update()
            if b.is_hovered then
                b:was_clicked()
            end
        end
    end
end

function is_valid_spot(x, y)
    for _, c in ipairs(cases) do
        if not c.picked and c.spot[1] == x and c.spot[2] == y then
            return true
        end
    end
    return false
end

function update_topbar(n_cases)
    local _txt = ""
    if player_case then
        if round < 1 then
            _txt = "Pick " .. n_cases .. " more cases"
        else
            _txt = "Pick " .. n_cases .. " case"
        end
    else
        _txt = "Pick your case"
    end
    top_bar:set_text(_txt)
end

function move_selector(dir)
    if can_player_input then
        if dir == "up" then
            selector_index[1] = clamp(0, selector_index[1] - 1, 4)
        elseif dir == "down" then
            selector_index[1] = clamp(0, selector_index[1] + 1, 3)
        elseif dir == "left" then
            selector_index[2] = clamp(0, selector_index[2] - 1, 5)
        elseif dir == "right" then
            selector_index[2] = clamp(0, selector_index[2] + 1, 5)
        end
    end
end

function update_deal_accepted()
    if btnp(5) then
        reset_game()
    end
end

function update_game_over()
    if btnp(5) then
        reset_game()
    end
end

function draw_border()
    top_bar:draw()
    line(0, 8, 240, 8, BORDER_COLOR)
    line(0, 134, 240, 134, BORDER_COLOR)
    line(0, 0, 240, 0, BORDER_COLOR)
    line(0, 0, 0, 134, BORDER_COLOR)
    line(155, 8, 155, 155, BORDER_COLOR)
    line(239, 0, 239, 134, BORDER_COLOR)
end

function draw_title()
    print("Accept", 50, 42, FONT_COLOR)
    print("or", 80, 56, FONT_COLOR)
    print("Reject", 90, 72, FONT_COLOR)
    print("Press O to play", 70, 110, FONT_COLOR)
end

function draw_pick_case()
    for _, r in ipairs(cases) do
        if not r.picked or 4 == 4 then
            r:draw()
        end
    end

    draw_display_values()

    if case_manager.t < 90 then
        print("Case " .. case_manager.cover_num .. " had", 185, 120, FONT_COLOR, false, 1, true)
        print("$" .. comma_value(case_manager.inside_num), 185, 128, FONT_COLOR, false, 1, true) --, false, 1, true)
    end

    print("Click to select", 3, 125, FONT_COLOR, false, 1, true)
    if player_case then
        print("Your Case: " .. player_case.number, 110, 128, FONT_COLOR, false, 1, true)
    end

    
end

function draw_display_values()
    local _start_y = 15
    rectfill(156, 9, 250, 133, 0)


    for i = 1, 12 do
        if game_values[i].in_play then
            col = 12
        else
            col = 5
        end
        print("$" .. comma_value(game_values[i].value), 36 + 123, _start_y + (i - 1) * 8, col, false, 1, true)
    end

    for i2 = 1, 12 do
        if game_values[i2 + 12].in_play then
            col = 12
        else
            col = 5
        end
        print("$" .. comma_value(game_values[i2 + 12].value), 63 + 123, _start_y + (i2 - 1) * 8, col, false, 1, true)
    end
end

function draw_offer()
    if round == 7 then
        print("LAST OFFER", 56, 20, FONT_COLOR)
    end
    print("Offer: $" .. comma_value(current_offer), 56, 30, FONT_COLOR)
    btn_deal:draw()
    btn_no_deal:draw()
    draw_display_values()


    print("Press O to select", 3, 127, FONT_COLOR, false, 1, true)

end

function draw_game_over()
    print("You turned down all offers", 60, 30, FONT_COLOR)
    print("Your Case Value", 60, 45, FONT_COLOR)
    print("$" .. comma_value(player_case.value), 60, 58, FONT_COLOR)
    print("X to reset", 60, 120, FONT_COLOR)
end

function draw_deal_accepted()
    print("You accepted", 60, 30, FONT_COLOR)
    print("$" .. comma_value(current_offer), 60, 38, FONT_COLOR)
    print("Your case had", 60, 50, FONT_COLOR)
    print("$" .. comma_value(player_case.value), 60, 58, FONT_COLOR)

    if current_offer > player_case.value then
        print("Well played", 60, 100, FONT_COLOR)
    else
        print("Better luck next time", 60, 100, FONT_COLOR)
    end

    print("X to reset", 60, 120, FONT_COLOR)
end


function comma_value(amount)
    local formatted = amount
    local _k = nil
    while true do
        formatted, _k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
        if (_k == 0) then
            break
        end
    end
    return formatted
end

function clamp(low, n, high)
    return math.min(math.max(n, low), high)
end

function lerp(a, b, t)
    return a + (b - a) * t
end



:: topbar.lua
--[[pod_format="raw",created="2025-03-27 22:57:41",modified="2025-03-28 21:24:59",revision=345]]

local top_bar = {
    x = 0,
    y = 1,
    str = "test",
    w = 0,
    col = FONT_COLOR,
    set_text = function(self, text)
        self.str = text
        self.w = print(text, 0, -6)
    end,
    draw = function(self)
        print(self.str, self.x, self.y, FONT_COLOR)
    end,
    update = function(self)
        self.x = self.x - 0.5
        if self.x + self.w <= 0 then
            self.x = 241
        end
    end,
}

return top_bar
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDIyOjM5OjEyIixpY29uPXVzZXJkYXRhKCJ1
OCIsMTYsMTYsIjAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwNzA3MDcwNzAxMDcw
NzA3MDcwMTA3MDcwNzA3MDEwMTA3MDEwMTA3MDEwNzAxMDEwNzAxMDcwMTAxMDcwMTAxMDcwNzA3
MDcwMTA3MDcwNzA3MDEwNzA3MDcwNzAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDcwNzA3MDcwMTA3MDcwNzA3MDEwNjA2
MDYwNjAxMDEwNzAxMDEwNzAxMDcwMTAxMDcwMTA2MDEwMTA2MDEwMTA3MDcwNzA3MDEwNzA3MDcw
NzAxMDYwNjA2MDYwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAx
MDEwMTAxMDEwMTAxMDEwMTAxMDEwMTA2MDYwNjA2MDEwNzA3MDcwNzAxMDcwNzA3MDcwMTAxMDYw
MTAxMDYwMTA3MDEwMTA3MDEwNzAxMDEwNzAxMDEwNjA2MDYwNjAxMDcwNzA3MDcwMTA3MDcwNzA3
MDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MTAxMDEwMTAxIiksbW9kaWZpZWQ9IjIwMjUtMDMtMjggMjE6MjQ6NTkiLHJ1bnRpbWU9MTYsd29y
a3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSM4OSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2Nh
dGlvbj0idG9wYmFyLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJjYXNlLmx1
YSMyNiIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iYnV0dG9uLmx1YSM0NCIsd29ya3Nw
YWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xv
Y2F0aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNm
eCIsd29ya3NwYWNlX2luZGV4PTR9fV1d
:: [eoc]
